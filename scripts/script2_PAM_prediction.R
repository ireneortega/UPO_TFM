# PART 3: BLAST needs to be performed manually as the spacers FASTA files are too heavy (Error: URL is too long...)".

library(taxonomizr)
library(Spacer2PAM)
library(dplyr)

# Read spacers dataframe
df_spacers_filtered <- read.table(file = "./spacers_for_df2fasta.tab", sep = "\t", header = TRUE, check.names = FALSE)

# Remove unnecessary columns for df2fasta()
df_spacers_filtered_sql <- df_spacers_filtered %>%
  dplyr::select(Spacers, Array.Orientation, Repeat, Array, Spacer, Subtype)

# Create list of BLAST filepaths 
blastn_files_list <- list.files(path = ".", full.names = TRUE, recursive = FALSE, pattern = ".csv")

for (blastn_file in blastn_files_list) { # For each BLAST file… (that is for each CRISPR array subtype…)
  print(paste0("Spacer2PAM will predict the spacers for the following BLAST file: ", blastn_file))
  
  alignmentDF <- alignmentCSV2DF(blastn_file) # Convert BLAST file into a dataframe
  
  # PART 4: the resulting dataframe alignmentDF can then be passed to joinSpacerDFandAlignmentDF(). This function joins the two dataframes into a new dataframe named "joineddata", assigning spacer information to each alignment in the hit table. This function also converts the accession number of the alignment to the genus (TaxaID) and species name of the organism that encodes the alignment sequence using the taxonomizr package.
  CRISPR_subtype <- sub("./(.*)_.*", "\\1", blastn_file) # Get CRISPR arary subtype from the blastn filepath
  CRISPR_subtype <- sub("/", "", CRISPR_subtype)
  
  # Set the name of the CRISPR-Cas system and define file output name
  setCRISPRInfo(genus = "Pseudomonas",
                species = "aeruginosa",
                strain = CRISPR_subtype,
                crisprSystemNumber = "CRISPR-Cas") # It will only be considered for the fasta filename
  
  joinSpacerDFandAlignmentDF(alignmentDF = alignmentDF, spacerDF = df_spacers_filtered_sql, accessionDatabaseLocation = '/home/iortsan/tfm/sql_db/accessionTaxa.sql') # Requires taxonomizr library
  
  write.table(joineddata, file = paste0('./joineddata_', CRISPR_subtype, '.tab'), row.names = FALSE)
  
  
  # PART 5: the resulting dataframe "joineddata" is sufficient for PAM prediction by join2PAM(). The function join2PAM is the core of Spacer2PAM and predicts a PAM (protospacer adjacent motifs) sequence from the alignments generated by BLAST. The function filters alignment data and then predict protospacer adjacent motifs. The output of join2PAM is a dataframe named "collectionFrame" that summarizes the filtering process and records the upstream and downstream predicted PAMs as well as their associated PAM score. Details on PAM identification and scoring can be found in the vignette associated with Spacer2PAM
  print(paste0("Predicting consensus PAM sequences for CRISPR-Cas array subtype ", CRISPR_subtype, "..."))
  join2PAM(joinedData = joineddata, numGapsRange = c(0,1,2,3), e.valueRange = c(0.01,0.05,0.5,1), nucleotidesShorterThanProtospacerRange = c(0,1,3,5), queryStartRange = c(1,2,5,7), saveLogo = FALSE) # 'Comprehensive' methods with 256 filteres without saving the Sequence logo for each prediction
  
  write.table(collectionFrame, file = paste0('./collectionFrame_', CRISPR_subtype, '.tab'), row.names = FALSE)
  
  print(paste0("Prediction of consensus PAM sequences for CRISPR-Cas array subtype ", CRISPR_subtype, " finished!"))
} # Close for-loop to process the BLAST file for each CRISPR array subtype
